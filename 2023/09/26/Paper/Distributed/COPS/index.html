<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liyun-zhang.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Paper: Don’t Settle for Eventual: Scalable Causal Consistency for Wide-Area Storage with COPS @[toc] Purpose Issues Systems often sacrifice strong consistency to achieve these goals, exposing inconsis">
<meta property="og:type" content="article">
<meta property="og:title" content="COPS">
<meta property="og:url" content="http://liyun-zhang.github.io/2023/09/26/Paper/Distributed/COPS/index.html">
<meta property="og:site_name" content="LiyunZhang">
<meta property="og:description" content="Paper: Don’t Settle for Eventual: Scalable Causal Consistency for Wide-Area Storage with COPS @[toc] Purpose Issues Systems often sacrifice strong consistency to achieve these goals, exposing inconsis">
<meta property="og:locale">
<meta property="og:image" content="http://liyun-zhang.github.io/imgs/Distributed/COPS/models.png">
<meta property="article:published_time" content="2023-09-26T05:54:58.000Z">
<meta property="article:modified_time" content="2024-03-15T11:00:41.443Z">
<meta property="article:author" content="LiyunZhang">
<meta property="article:tag" content="Distributed System">
<meta property="article:tag" content="Consistency Level">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://liyun-zhang.github.io/imgs/Distributed/COPS/models.png">


<link rel="canonical" href="http://liyun-zhang.github.io/2023/09/26/Paper/Distributed/COPS/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://liyun-zhang.github.io/2023/09/26/Paper/Distributed/COPS/","path":"2023/09/26/Paper/Distributed/COPS/","title":"COPS"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>COPS | LiyunZhang</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LiyunZhang</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Purpose"><span class="nav-number">1.</span> <span class="nav-text">Purpose</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Model"><span class="nav-number">2.</span> <span class="nav-text">Model</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ALPS-systems"><span class="nav-number">2.1.</span> <span class="nav-text">ALPS systems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What-are-the-desirable-properties-of-ALPS-systems"><span class="nav-number">2.1.1.</span> <span class="nav-text">What are the desirable properties of ALPS systems?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-is-the-problem-of-linearizability"><span class="nav-number">2.1.2.</span> <span class="nav-text">What is the problem of linearizability?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Causal-consistency"><span class="nav-number">2.2.</span> <span class="nav-text">Causal+ consistency</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What-is-causal-consistency"><span class="nav-number">2.2.1.</span> <span class="nav-text">What is causal consistency?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-handle-conflicts"><span class="nav-number">2.2.2.</span> <span class="nav-text">How to handle conflicts?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-decide-which-write-is-the-last-write"><span class="nav-number">2.2.3.</span> <span class="nav-text">How to decide which write is the last write?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-are-other-consistency-models"><span class="nav-number">2.2.4.</span> <span class="nav-text">What are other consistency models?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-is-causal-ensured-in-COPS"><span class="nav-number">2.2.5.</span> <span class="nav-text">How is causal+ ensured in COPS?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Why-previous-systems-cannot-provide-scalability"><span class="nav-number">2.2.6.</span> <span class="nav-text">Why previous systems cannot provide scalability?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#COPS-system"><span class="nav-number">2.3.</span> <span class="nav-text">COPS system</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What-are-the-components-of-COPS"><span class="nav-number">2.3.1.</span> <span class="nav-text">What are the components of COPS?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-consistency-is-achieved-in-COPS"><span class="nav-number">2.3.2.</span> <span class="nav-text">What consistency is achieved in COPS?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key-value-store"><span class="nav-number">2.3.3.</span> <span class="nav-text">Key-value store</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#What-is-stored-in-COPS-storage"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">What is stored in COPS storage?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-COPS-support-scalability-in-KV-storage"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">How does COPS support scalability in KV-storage?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Client-library"><span class="nav-number">2.3.4.</span> <span class="nav-text">Client library</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#What-is-provided-in-the-client-API"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">What is provided in the client API?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#What-is-the-context-in-the-library"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">What is the context in the library?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#What-does-COPS-GT-store-in-context"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">What does COPS-GT store in context?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#What-are-the-concerns-of-the-COPS-GT-context"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">What are the concerns of the COPS-GT context?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#What-does-COPS-store-in-context"><span class="nav-number">2.3.4.5.</span> <span class="nav-text">What does COPS store in context?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-COPS-or-COPS-GT-write-to-the-local-cluster"><span class="nav-number">2.3.4.6.</span> <span class="nav-text">How does COPS (or COPS-GT) write to the local cluster?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-to-replica-writes-between-clusters"><span class="nav-number">2.3.4.7.</span> <span class="nav-text">How to replica writes between clusters?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-to-read-values-in-COPS"><span class="nav-number">2.3.4.8.</span> <span class="nav-text">How to read values in COPS?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Why-does-COPS-GT-need-to-provide-get-trans-What-is-wrong-with-the-get-interface"><span class="nav-number">2.3.4.9.</span> <span class="nav-text">Why does COPS-GT need to provide get_trans? What is wrong with the get interface?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-get-trans-work"><span class="nav-number">2.3.4.10.</span> <span class="nav-text">How does get_trans work?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Garbage-collection"><span class="nav-number">2.3.5.</span> <span class="nav-text">Garbage collection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-COPS-GT-collect-version-garbage"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">How does COPS-GT collect version garbage?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-COPS-GT-collect-dependency-garbage"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">How does COPS-GT collect dependency garbage?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-COPS-collect-client-metadata-garbage"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">How does COPS collect client metadata garbage?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fault-tolerance"><span class="nav-number">2.3.6.</span> <span class="nav-text">Fault tolerance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-COPS-handle-client-failures"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">How does COPS handle client failures?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-COPS-handle-key-value-node-failures"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">How does COPS handle key-value node failures?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#What-will-happen-when-the-datacenter-fails"><span class="nav-number">2.3.6.3.</span> <span class="nav-text">What will happen when the datacenter fails?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-COPS-with-conflict-detection-COPS-CD-detect-conflict"><span class="nav-number">2.3.6.4.</span> <span class="nav-text">How does COPS with conflict detection (COPS-CD) detect conflict?</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LiyunZhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">

  
  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://liyun-zhang.github.io/2023/09/26/Paper/Distributed/COPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LiyunZhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="COPS | LiyunZhang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          COPS
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-26 13:54:58" itemprop="dateCreated datePublished" datetime="2023-09-26T13:54:58+08:00">2023-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-03-15 19:00:41" itemprop="dateModified" datetime="2024-03-15T19:00:41+08:00">2024-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper-Notebook/" itemprop="url" rel="index"><span itemprop="name">Paper Notebook</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper-Notebook/Distributed-System/" itemprop="url" rel="index"><span itemprop="name">Distributed System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>Paper: <a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2020/papers/cops.pdf">Don’t Settle for Eventual: Scalable Causal Consistency for Wide-Area Storage with COPS</a></p>
<p>@[toc]</p>
<h1 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h1><ol>
<li>Issues<ul>
<li>Systems often sacrifice strong consistency to achieve these goals, exposing inconsistencies to their clients and necessitating complex application logic. </li>
<li>The author referred to systems with these four properties—Availability, low Latency, partition tolerance, and high Scalability—as ALPS systems. </li>
<li>Eventual consistent systems may expose versions that are out of order. </li>
</ul>
</li>
<li>Contribution:<ul>
<li>The author identified and defined a consistency model—causal consistency with convergent conflict handling, or causal+ —the strongest achieved under ALPS systems. <ul>
<li>The convergent conflict handling component of causal+ consistency ensures that replicas never permanently diverge and that conflicting updates to the same key are dealt with identically at all sites. </li>
<li>When combined with causal consistency, this property ensures that clients see only progressively newer versions of keys. </li>
</ul>
</li>
<li>The scalability of the Clusters of Order-Preserving Servers (COPS) system can enforce causal dependencies between keys stored across an entire cluster rather than a single server like previous systems. </li>
<li>In COPS-GT, the author introduced get transactions to obtain a consistent view of multiple keys without locking or blocking. </li>
</ul>
</li>
</ol>
<h1 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h1><h2 id="ALPS-systems"><a href="#ALPS-systems" class="headerlink" title="ALPS systems"></a>ALPS systems</h2><h3 id="What-are-the-desirable-properties-of-ALPS-systems"><a href="#What-are-the-desirable-properties-of-ALPS-systems" class="headerlink" title="What are the desirable properties of ALPS systems?"></a>What are the desirable properties of ALPS systems?</h3><ol>
<li><strong>Availability</strong>: <ul>
<li>All operations issued to the data store are completed successfully. </li>
<li>No operation can block indefinitely or return an error signifying that data is unavailable. </li>
</ul>
</li>
<li><strong>Low Latency</strong>: Client operations complete “quickly.” <ul>
<li>Commercial service-level objectives suggest an average performance of a few milliseconds and a worse-case performance (i.e., 99.9th percentile) of 10s or 100s milliseconds. </li>
</ul>
</li>
<li><strong>Partition Tolerance</strong>: The data store continues to operate under network partitions. </li>
<li><strong>High Scalability</strong>: The data store scales out linearly. Adding N resources to the system increases aggregate throughput and storage capacity by $O(N)$. </li>
<li><strong>Stronger Consistency</strong>: <ul>
<li>Linearizability dictates that operations appear to take effect across the entire system at a single instance between the invocation and completion of the operation. </li>
<li>Eventual consistency models not only might subsequent reads not reflect the latest value, but reads across multiple objects might reflect an incoherent mix of old and new values. </li>
</ul>
</li>
</ol>
<h3 id="What-is-the-problem-of-linearizability"><a href="#What-is-the-problem-of-linearizability" class="headerlink" title="What is the problem of linearizability?"></a>What is the problem of linearizability?</h3><ol>
<li>The CAP Theorem proves that a shared-data system with availability and partition tolerance cannot achieve linearizability. </li>
<li>Low latency—defined as latency less than the maximum wide area delay between replicas—has also been proven incompatible with linearizability and sequential consistency. </li>
</ol>
<h2 id="Causal-consistency"><a href="#Causal-consistency" class="headerlink" title="Causal+ consistency"></a>Causal+ consistency</h2><h3 id="What-is-causal-consistency"><a href="#What-is-causal-consistency" class="headerlink" title="What is causal consistency?"></a>What is causal consistency?</h3><ol>
<li>Values are stored and retrieved from logical replicas, each hosting the entire key space. </li>
<li>The potential causality between operations denoted by $\leadsto$: <ul>
<li><strong>Execution Thread</strong>: If $a$ and $b$ are two operations in a single thread of execution, then $a \leadsto b$ if operation $a$ happens before operation $b$. </li>
<li><strong>Gets From</strong>: If $a$ is a put operation and $b$ is a get operation that returns the value written by $a$, then $a \leadsto b$. </li>
<li><strong>Transitivity</strong>: For operations $a$, $b$, and $c$, if $a \leadsto b$ and $b \leadsto c$, then $a \leadsto c$. </li>
</ul>
</li>
<li>Causal consistency requires that values returned from get operations at a replica are consistent with the order defined by $\leadsto$ (causality). <ul>
<li>The operation that writes a value must appear after all operations that causally precede it. </li>
<li>If $a \not\leadsto b$ and $b \not\leadsto a$, then $a$ and $b$ are concurrent. Causal consistency does not order concurrent operations. </li>
</ul>
</li>
</ol>
<h3 id="How-to-handle-conflicts"><a href="#How-to-handle-conflicts" class="headerlink" title="How to handle conflicts?"></a>How to handle conflicts?</h3><ol>
<li>If $a$ and $b$ are both put to the same key, then they are in conflict. <ul>
<li>Conflicts are unordered by causal consistency and allow replicas to diverge forever. </li>
<li>Conflicts may represent an exceptional condition that requires special handling. </li>
</ul>
</li>
<li>Convergent conflict handling requires that all conflicting puts be handled in the same manner at all replicas, using a handler function $h$. <ul>
<li>This handler function $h$ must be <strong>associative</strong> and <strong>commutative</strong> so that replicas can handle conflicting writes in the order they receive them and that the results of these handlings will converge. <ul>
<li>The last-writer-wins rule (Thomas’s write rule) is one of the conflicting writes that occurred later and was overwritten by the “earlier” write. </li>
<li>The default COPS system avoids conflict detection using a last-writer-wins strategy. The “last” write is determined by comparing version numbers. </li>
<li>Another way is to mark them as conflicting and require resolution through other means. </li>
</ul>
</li>
</ul>
</li>
<li>All potential forms of convergent conflict handling avoid the first issue by ensuring replicas reach the same result after exchanging operations. </li>
<li>The second conflict issue is only avoided using more explicit conflict resolution procedures.<ul>
<li>These explicit procedures provide greater application flexibility but require additional programmer complexity and performance overhead. </li>
</ul>
</li>
</ol>
<h3 id="How-to-decide-which-write-is-the-last-write"><a href="#How-to-decide-which-write-is-the-last-write" class="headerlink" title="How to decide which write is the last write?"></a>How to decide which write is the last write?</h3><ol>
<li>It uses a last-write-win strategy. So the problem is how to decide which write is the last. </li>
<li>The decision is made by attaching each put’s current wall-clock time as the version number. <ul>
<li>Local shard server assigns <code>version number (v#) = time</code> when it receives client <code>put()</code></li>
<li>Remote datacenter receives <code>put(k, -, v#)</code><ul>
<li>If <code>v#</code> is larger than the version of the currently stored value for k, it replaces the current value with a new value and updates <code>v#</code>. </li>
<li>Otherwise, it just ignores new values. </li>
</ul>
</li>
</ul>
</li>
<li>If two <code>put(k)</code> happen simultaneously at different datacenters, we can break the tie with a unique ID in the low bits of <code>v#</code>. </li>
<li>COPS uses Lamport clocks to assign <code>v#</code><ul>
<li>Each server implements a “Lamport clock” or “logical clock.” <ul>
<li><code>Tmax = highest v# seen</code> (from self and others)</li>
<li><code>T = max(Tmax + 1, wall-clock time)</code></li>
</ul>
</li>
</ul>
</li>
<li>In the naive strategy, if one datacenter’s (or server’s) clock is fast by an hour, it will cause that datacenter’s values to win. In the worst case, it prevents any other update for an hour. <ul>
<li>However, in  COPS, if some server has a fast clock, everyone who sees a version from that server will advance their Lamport clock. </li>
</ul>
</li>
</ol>
<h3 id="What-are-other-consistency-models"><a href="#What-are-other-consistency-models" class="headerlink" title="What are other consistency models?"></a>What are other consistency models?</h3><ol>
<li><p>Linearizability (or strong consistency) maintains a global, real-time ordering. </p>
</li>
<li><p>Sequential consistency ensures at least a global ordering. </p>
</li>
<li><p>Causal consistency ensures partial orderings between dependent operations. </p>
</li>
<li><p>FIFO (PRAM) consistency only preserves the partial ordering of an execution thread, not between threads. </p>
</li>
<li><p>Per-key sequential consistency ensures that, for each key, all operations have a global order. </p>
</li>
<li><p>Eventual consistency is a “catch-all” term used today, suggesting eventual convergence with some agreement. </p>
</li>
<li><p>The strength of those models is as shown below:</p>
<p><img src="/imgs/Distributed/COPS/models.png" width="50%"></p>
</li>
</ol>
<h3 id="How-is-causal-ensured-in-COPS"><a href="#How-is-causal-ensured-in-COPS" class="headerlink" title="How is causal+ ensured in COPS?"></a>How is causal+ ensured in COPS?</h3><ol>
<li><p><strong>Progressing property</strong></p>
<ul>
<li><p>Different values a key has are referred to as the versions of a key, which are denoted $key_{version}$. </p>
</li>
<li><p>In COPS, versions are assigned in a manner that ensures that if $x_i \leadsto y_j$ then $i &lt; j$. </p>
</li>
<li><p>Once a replica in COPS returns the version $i$ of a key, $x_i$, causal+ consistency ensures it will then only return that version or a causally later version. </p>
</li>
<li><p>The handling of a conflict is causally later than the conflicting puts it resolves. </p>
<ul>
<li><p>Assume a replica first returns $x_i$ and then $x_k$, where $i \ne k$ and $x_i \not\leadsto x_k$. </p>
</li>
<li><p>Causal consistency ensures that if $x_k$ is returned after $x_i$, then $x_k \not\leadsto x_i$, and so $x_i$ and $x_k$ conflict. </p>
</li>
<li><p>But, if $x_i$ and $x_k$ conflict, then convergent conflict handling ensures that as soon as both are present at a replica, their handling $h(x_i,x_k)$, which is causally after both will be returned instead of either $x_i$ or $x_k$, which contradicts our assumption. </p>
</li>
</ul>
</li>
<li><p>Thus, each replica in COPS always returns non-decreasing versions of a key. </p>
</li>
</ul>
</li>
<li><p>$y_j$ depends on $x_i$ if and only if $put(x_i) \leadsto put(y_j)$. </p>
<ul>
<li>These dependencies are, in essence, the reverse of the causal ordering of writes. </li>
<li>COPS provides causal+ consistency during replication by writing a version only after writing all of its dependencies. </li>
</ul>
</li>
</ol>
<h3 id="Why-previous-systems-cannot-provide-scalability"><a href="#Why-previous-systems-cannot-provide-scalability" class="headerlink" title="Why previous systems cannot provide scalability?"></a>Why previous systems cannot provide scalability?</h3><ol>
<li><p>They all use a form of log serialization and exchange. </p>
<ul>
<li><p>All operations at a logical replica are written to a single log in serialized order, commonly marked with a version vector. </p>
</li>
<li><p>Log-exchange-based serialization inhibits replica scalability, as it relies on a single serialization point in each replica to establish order. </p>
</li>
<li>Either causal dependencies between keys are limited to the set of keys stored on one node, or a single node (or replicated state machine) must provide a commit ordering and log for all operations across a cluster.</li>
</ul>
</li>
<li><p>In COPS, nodes in each datacenter are responsible for different partitions of the keyspace, but the system can track and enforce dependencies between keys stored on other nodes. </p>
<ul>
<li>COPS explicitly encodes dependencies in metadata associated with each key’s version. </li>
<li>When keys are replicated remotely, the receiving datacenter performs dependency checks before committing the incoming version.</li>
</ul>
</li>
</ol>
<h2 id="COPS-system"><a href="#COPS-system" class="headerlink" title="COPS system"></a>COPS system</h2><h3 id="What-are-the-components-of-COPS"><a href="#What-are-the-components-of-COPS" class="headerlink" title="What are the components of COPS?"></a>What are the components of COPS?</h3><ol>
<li>Key-value store<ul>
<li>Each key-value pair has associated metadata. <ul>
<li>In COPS, this metadata is a version number. </li>
<li>In COPS-GT, it is both a version number and a list of dependencies (other keys and their respective versions). </li>
</ul>
</li>
<li>The key-value store exports three additional operations as part of its key-value interface: <code>get_by_version</code>, <code>put_after</code>, and <code>dep_check</code>. </li>
<li>For COPS-GT, the system keeps around old versions of key-value pairs, not just the most recent put, to ensure that it can provide get transactions. </li>
</ul>
</li>
<li>Client library<ul>
<li>The client library exports two main operations to applications: reads via <code>get</code> (in COPS) or <code>get_trans</code> (in COPS-GT) and writes via <code>put</code>. </li>
<li>The client library also maintains a state of a client’s current dependencies through a <code>context</code> parameter in the client library API. </li>
</ul>
</li>
<li>A client of COPS is an application that uses the COPS client library to call directly into the COPS key-value store. </li>
<li>Clients communicate only with their local COPS cluster running in the same datacenter.</li>
</ol>
<h3 id="What-consistency-is-achieved-in-COPS"><a href="#What-consistency-is-achieved-in-COPS" class="headerlink" title="What consistency is achieved in COPS?"></a>What consistency is achieved in COPS?</h3><ol>
<li>Each local COPS cluster is a linearizable (strongly consistent) key-value store. <ul>
<li>Linearizable systems can be implemented scalably by partitioning the keyspace into N linearizable partitions. </li>
<li>The composability of linearizability ensures that the resulting system remains linearizable. </li>
<li>Linearizability is acceptable locally because we expect very low latency and no partitions within a cluster. </li>
</ul>
</li>
<li>Replication between COPS clusters happens asynchronously to ensure low latency for client operations and availability in the face of external partitions. </li>
<li>The COPS design strives to provide causal+ consistency with resource and performance overhead similar to existing eventual consistent systems. <ul>
<li>COPS and COPS-GT need to minimize the overhead of consistency-preserving replication<ul>
<li>A naive implementation, however, would require checks on all of a value’s dependencies. </li>
</ul>
</li>
<li>COPS-GT needs to minimize space requirements</li>
<li>COPS-GT needs to ensure fast <code>get_trans</code> operations<ul>
<li>A naive algorithm could block and take an unbounded number of get rounds to complete. </li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Key-value-store"><a href="#Key-value-store" class="headerlink" title="Key-value store"></a>Key-value store</h3><h4 id="What-is-stored-in-COPS-storage"><a href="#What-is-stored-in-COPS-storage" class="headerlink" title="What is stored in COPS storage?"></a>What is stored in COPS storage?</h4><ol>
<li>COPS must track the versions of written values and their dependencies in the case of COPS-GT. </li>
<li>In COPS, the system stores each key’s most recent version number and value. </li>
<li>In COPS-GT, the system maps each key to a list of version entries consisting of <code>&lt;version, value, deps&gt;</code>. <ul>
<li>The <code>deps</code> field lists the version’s zero or more dependencies; each dependency is a <code>&lt;key, version&gt;</code> pair. </li>
</ul>
</li>
</ol>
<h4 id="How-does-COPS-support-scalability-in-KV-storage"><a href="#How-does-COPS-support-scalability-in-KV-storage" class="headerlink" title="How does COPS support scalability in KV-storage?"></a>How does COPS support scalability in KV-storage?</h4><ol>
<li>It partitions the keyspace across a cluster’s nodes using consistent hashing. </li>
<li>Every key stored in COPS has one primary node in each cluster. <ul>
<li>The set of primary nodes for a key across all clusters is the <strong>equivalent nodes</strong> for that key. </li>
<li>After a write completes locally, the primary node places it in a replication queue, sending it asynchronously to remote equivalent nodes. </li>
<li>Those nodes, in turn, wait until the value’s dependencies are satisfied in their local cluster before locally committing the value. </li>
<li>This dependency-checking mechanism ensures that writes happen in a causally consistent order and reads never block. </li>
</ul>
</li>
<li>In practice, COPS’s consistent hashing assigns each node responsibility for a few different key ranges. <ul>
<li>Key ranges may have different sizes and node mappings in different datacenters.</li>
<li>The number of equivalent nodes with which a given node must communicate is proportional to the number of datacenters (i.e., communication is not all-to-all between nodes in different datacenters).</li>
</ul>
</li>
</ol>
<h3 id="Client-library"><a href="#Client-library" class="headerlink" title="Client library"></a>Client library</h3><h4 id="What-is-provided-in-the-client-API"><a href="#What-is-provided-in-the-client-API" class="headerlink" title="What is provided in the client API?"></a>What is provided in the client API?</h4><ol>
<li>$ctx_id\leftarrow createContext()$</li>
<li>$bool\leftarrow deleteContext(ctx_id)$</li>
<li>$bool\leftarrow put(key,value,ctx_id)$</li>
<li>$value\leftarrow get(key,ctx_id)$ for COPS, or $\langle values\rangle\leftarrow get_trans(\langle keys\rangle,ctx_id)$ for COPS-GT<ul>
<li>COPS-GT provides <code>get_trans</code>, which returns a consistent view of multiple key-value pairs in a single call. </li>
</ul>
</li>
</ol>
<h4 id="What-is-the-context-in-the-library"><a href="#What-is-the-context-in-the-library" class="headerlink" title="What is the context in the library?"></a>What is the context in the library?</h4><ol>
<li>All functions take a context argument, which the library uses internally to track causal dependencies across each client’s operations. </li>
<li>The context defines the causal+ “thread of execution.” A single process may contain many separate threads of execution. </li>
<li>By separating different threads of execution, COPS avoids false dependencies that would result from intermixing them. </li>
</ol>
<h4 id="What-does-COPS-GT-store-in-context"><a href="#What-does-COPS-GT-store-in-context" class="headerlink" title="What does COPS-GT store in context?"></a>What does COPS-GT store in context?</h4><ol>
<li><p>The client library in COPS-GT stores the client’s context in a table of $\langle key, version, deps\rangle$ entries. </p>
<ul>
<li>Clients reference their context using a context ID ($ctx_id$) in the API. </li>
</ul>
</li>
<li>When a client gets a key from the data store, the library adds it and its causal dependencies to the context. </li>
<li>When a client puts a value, the library sets the put’s dependencies to the most recent version of each key in the current context. <ul>
<li>A successful put into the data store returns the version number v assigned to the written value. </li>
<li>The client library then adds this new entry, $\langle key, v, D\rangle$, to the context. </li>
</ul>
</li>
</ol>
<h4 id="What-are-the-concerns-of-the-COPS-GT-context"><a href="#What-are-the-concerns-of-the-COPS-GT-context" class="headerlink" title="What are the concerns of the COPS-GT context?"></a>What are the concerns of the COPS-GT context?</h4><ol>
<li>The context, therefore, includes all values previously read or written in the client’s session and all of those dependencies. </li>
<li>State requirements for storing these dependencies in the client library and the data store. <ul>
<li>COPS-GT provides garbage collection to mitigate the client and data-store state required to track dependencies. </li>
</ul>
</li>
<li>Several potential checks must be performed to ensure causal consistency when replicating writes between clusters. <ul>
<li>The dependencies that must be checked are termed the nearest dependencies. <ul>
<li>If the storage node commits a node, determining its direct dependencies are committed, it can infer that all former dependencies are also committed. </li>
<li>Hence, each dependency check only needs to check nodes within $1$ step in the graph of causal dependencies. </li>
</ul>
</li>
<li>The nearest dependencies are sufficient for the key-value store to provide causal+ consistency. </li>
<li>The full dependency list is only needed to provide <code>get_trans</code> operations in COPS-GT. </li>
</ul>
</li>
</ol>
<h4 id="What-does-COPS-store-in-context"><a href="#What-does-COPS-store-in-context" class="headerlink" title="What does COPS store in context?"></a>What does COPS store in context?</h4><ol>
<li>It does not store or even retrieve the dependencies of any value it gets<ul>
<li>The retrieved value is nearer than any of its dependencies, rendering them unnecessary. </li>
<li>The COPS client library stores only $\langle key, version\rangle$ entries. </li>
</ul>
</li>
<li>For a get operation, the retrieved $\langle key, version\rangle$ is added to the context. </li>
<li>For a put operation, the library uses the current context as the nearest dependencies, clears the context, and then repopulates it with only this put. <ul>
<li>This put depends on all previous key-version pairs and thus is nearer than them. </li>
</ul>
</li>
</ol>
<h4 id="How-does-COPS-or-COPS-GT-write-to-the-local-cluster"><a href="#How-does-COPS-or-COPS-GT-write-to-the-local-cluster" class="headerlink" title="How does COPS (or COPS-GT) write to the local cluster?"></a>How does COPS (or COPS-GT) write to the local cluster?</h4><ol>
<li>All writes in COPS first go to the client’s local cluster and then propagate asynchronously to remote clusters. </li>
<li>The key-value store exports a single API call to provide both operations: $\langle bool,vers\rangle \leftarrow put_after(key,val,[deps],nearest,vers=\empty)$</li>
<li>When a client calls $put (key,val,ctx_id)$, <ul>
<li>The library computes the complete set of dependencies <code>deps</code> and identifies some of those dependency tuples as the value’s nearest ones. </li>
<li>The library then calls put after without the version argument (i.e., it sets $version=\empty$). </li>
<li>The library includes <code>deps</code> in the put_after call in COPS-GT because dependencies must be stored with the value. </li>
<li>In COPS, the library only needs to include the nearest and does not include <code>deps</code>. </li>
</ul>
</li>
<li>The key’s primary storage node in the local cluster assigns the key a version number and returns it to the client library. </li>
<li>Each client is restricted to a single outstanding put; this is necessary because later puts must know the version numbers of earlier puts so that they may depend on them. </li>
<li>The put-after operation ensures that val is committed to each cluster only after all of the entries in its dependency list have been written. <ul>
<li>This property is automatically held in the client’s local cluster, as the local store provides linearizability. </li>
<li>If $y$ depends on $x$, then $put(x)$ must have been committed before $put(y)$ was issued. </li>
</ul>
</li>
</ol>
<h4 id="How-to-replica-writes-between-clusters"><a href="#How-to-replica-writes-between-clusters" class="headerlink" title="How to replica writes between clusters?"></a>How to replica writes between clusters?</h4><ol>
<li>After a write commits locally, the primary storage node asynchronously replicates that writes to its equivalent nodes in different clusters using a stream of <code>put_after</code> operations. <ul>
<li>The primary node includes the key’s version number in the put-after the call. </li>
<li>The <code>deps</code> argument is included in COPS-GT and not included in COPS. </li>
</ul>
</li>
<li>It requires the remote nodes receiving updates to commit an update only after its dependencies have been committed to the same cluster. <ul>
<li>A node that receives a put-after a request from another cluster must determine if the value’s nearest dependencies have already been satisfied locally. </li>
<li>It does so by issuing a check to the local nodes responsible for those dependencies: $bool\leftarrow dep_check(key, version)$</li>
<li>The way that nearest dependencies are computed ensures that all dependencies have been satisfied before the value is committed, ensuring causal consistency. </li>
</ul>
</li>
</ol>
<h4 id="How-to-read-values-in-COPS"><a href="#How-to-read-values-in-COPS" class="headerlink" title="How to read values in COPS?"></a>How to read values in COPS?</h4><ol>
<li>Reads are satisfied in the local cluster. </li>
<li>The library issues a read to the node responsible for the key in the local cluster: $\langle value, version,deps\rangle\leftarrow get_by_version(key,version=LATEST)$</li>
<li>This read can request either the latest version of the key or a specific older one. Requesting a particular version is necessary to enable get transactions. </li>
<li>Upon receiving a response, the client library adds the $\langle key,version,[deps]\rangle$ tuple to the client context and returns value to the calling code. </li>
<li>The <code>deps</code> are stored only in COPS-GT, not in COPS. </li>
</ol>
<h4 id="Why-does-COPS-GT-need-to-provide-get-trans-What-is-wrong-with-the-get-interface"><a href="#Why-does-COPS-GT-need-to-provide-get-trans-What-is-wrong-with-the-get-interface" class="headerlink" title="Why does COPS-GT need to provide get_trans? What is wrong with the get interface?"></a>Why does COPS-GT need to provide get_trans? What is wrong with the get interface?</h4><ol>
<li>Reading a set of dependent keys using a single-key get interface cannot ensure causal+ consistency, even though the data store itself is causal+ consistent. </li>
<li>It may have a “time-to-check-to-time-to-use” race condition, i.e., check operation and usage is not an atomic operation. </li>
<li>The standard way to achieve such a guarantee is to read and write all related keys in a transaction.<ul>
<li>This requires a single serialization point for all grouped keys, which COPS avoids for greater scalability and simplicity. </li>
</ul>
</li>
</ol>
<h4 id="How-does-get-trans-work"><a href="#How-does-get-trans-work" class="headerlink" title="How does get_trans work?"></a>How does get_trans work?</h4><ol>
<li>To retrieve multiple values in a causal+ consistent manner, client calls get trans with the desired set of keys. </li>
<li><p>In the first round, the library issues <code>n</code> concurrent <code>get_by_version</code> operations to the local cluster, one for each key the client listed in <code>get_trans</code>. </p>
<ul>
<li>Because COPS-GT commits writes locally, the local data store guarantees that these explicitly listed keys’ dependencies are satisfied.</li>
<li><p>All listed keys have been written locally, and their reads will immediately be returned. </p>
</li>
<li><p>Each <code>get_by_version</code> operation returns a $\langle value, version, deps\rangle$ tuple, where <code>deps</code> is a list of keys and versions. </p>
</li>
</ul>
</li>
<li><p>The client library then examines every dependency entry $\langle key, version\rangle$. </p>
<ul>
<li>The causal dependencies for that result are satisfied if either the client did not request the dependent key or it did, the version it retrieved was $≥$ the version in the dependency list. </li>
</ul>
</li>
<li><p>For all keys that are not satisfied, the library issues a second round of concurrent get by version operations. </p>
<ul>
<li>The version requested will be the newest version seen in any dependency list from the first round. </li>
<li>These versions satisfy all causal dependencies from the first round because they are $≥$ the needed versions. </li>
<li>Because dependencies are transitive and these second-round versions depend on versions retrieved in the first round, they do not introduce any new dependencies that must be satisfied. </li>
</ul>
</li>
<li><p>The second round happens only when the client must read newer versions than those retrieved in the first round. </p>
<ul>
<li>This case occurs only if keys involved in the get transaction are updated during the first round.</li>
</ul>
</li>
</ol>
<h3 id="Garbage-collection"><a href="#Garbage-collection" class="headerlink" title="Garbage collection"></a>Garbage collection</h3><h4 id="How-does-COPS-GT-collect-version-garbage"><a href="#How-does-COPS-GT-collect-version-garbage" class="headerlink" title="How does COPS-GT collect version garbage?"></a>How does COPS-GT collect version garbage?</h4><ol>
<li>The <code>get_trans</code> algorithm limits the number of versions needed to complete a get transaction. <ul>
<li>COPS-GT limits the total running time of get trans through a configurable parameter, <code>trans_time</code>. </li>
<li>If the timeout fires, the client library will restart the get trans call and satisfy the transaction with newer versions of the keys. </li>
</ul>
</li>
<li>After a new version of a key is written, COPS-GT only needs to keep the old version around for <code>trans_time</code> plus a small delta for clock skew. </li>
<li>The space overhead is bounded by the number of old versions created within the <code>trans_time</code>. <ul>
<li>This number is determined by the maximum write throughput that the node can sustain. </li>
<li>This overhead is per-machine and does not grow with the cluster size or the number of datacenters. </li>
</ul>
</li>
</ol>
<h4 id="How-does-COPS-GT-collect-dependency-garbage"><a href="#How-does-COPS-GT-collect-dependency-garbage" class="headerlink" title="How does COPS-GT collect dependency garbage?"></a>How does COPS-GT collect dependency garbage?</h4><ol>
<li>COPS-GT can garbage collect these dependencies once the versions associated with old dependencies are no longer needed for correctness in get transaction operations. </li>
<li>After <code>trans_time</code> seconds after a value has been committed in all datacenters, COPS-GT can clean a value’s dependencies. <ul>
<li>To clean dependencies, each remote datacenter notifies the originating datacenter when the write has been committed and the timeout period has elapsed.</li>
<li>Once all datacenters have confirmed, the originating datacenter cleans its dependencies and informs the others to do likewise. </li>
</ul>
</li>
<li>To minimize bandwidth devoted to cleaning dependencies, a replica only notifies the originating datacenter if this version of a key is the newest after <code>trans_time</code> seconds<ul>
<li>If it is not, there is no need to collect the dependencies because the entire version will be collected. </li>
</ul>
</li>
<li>Under regular operation, dependencies are garbage collected after <code>trans_time</code> plus a round-trip time. </li>
<li>During a partition, dependencies on the most recent versions of keys cannot be collected. </li>
</ol>
<h4 id="How-does-COPS-collect-client-metadata-garbage"><a href="#How-does-COPS-collect-client-metadata-garbage" class="headerlink" title="How does COPS collect client metadata garbage?"></a>How does COPS collect client metadata garbage?</h4><ol>
<li>The COPS client library tracks all operations during a client session (single thread of execution) using the $ctx_id$ passed with all operations. <ul>
<li>In both systems, each get since the last put adds another nearest dependency. </li>
<li>Additionally, in COPS-GT, all new values and their dependencies are returned in get trans operations, and all put operations add normal dependencies. </li>
</ul>
</li>
<li>Clients need to track dependencies only until they are guaranteed to be satisfied everywhere. </li>
<li>Once a <code>put_after</code> commits successfully to all datacenters, COPS flags that key version as <em>never-depend</em> to indicate that clients need not express a dependence upon it. <ul>
<li>The client library will immediately remove a never-depend item from the list of dependencies in the client context. </li>
<li>Anything that a never-depend key depended on must have been flagged never-depend, so it too can be garbage collected from the context. </li>
</ul>
</li>
<li>The COPS storage nodes remove unnecessary dependencies from <code>put_after</code> operations. <ul>
<li>When a node receives a <code>put_after</code>, it checks each item in the dependency list and removes items with version numbers older than a global checkpoint time. </li>
</ul>
</li>
</ol>
<h3 id="Fault-tolerance"><a href="#Fault-tolerance" class="headerlink" title="Fault tolerance"></a>Fault tolerance</h3><h4 id="How-does-COPS-handle-client-failures"><a href="#How-does-COPS-handle-client-failures" class="headerlink" title="How does COPS handle client failures?"></a>How does COPS handle client failures?</h4><ol>
<li>From the storage system’s perspective, if a client fails, it simply stops issuing new requests; no recovery is necessary. </li>
<li>From a client’s perspective, COPS’s dependency tracking makes it easier to handle failures of other clients by ensuring properties such as referential integrity. </li>
</ol>
<h4 id="How-does-COPS-handle-key-value-node-failures"><a href="#How-does-COPS-handle-key-value-node-failures" class="headerlink" title="How does COPS handle key-value node failures?"></a>How does COPS handle key-value node failures?</h4><ol>
<li><p>COPS can use any underlying fault-tolerant linearizable key-value store. </p>
<ul>
<li>The author uses chain replication within a cluster to mask node failures. </li>
</ul>
</li>
<li><p>Dependency garbage collection follows a similar pattern of interlocking chains. </p>
<p>Version garbage is collected locally on each node and can operate as in the single-node case. </p>
<p>The global checkpoint time calculation for client metadata garbage collection operates normally, with each tail updating its corresponding key range minimums. </p>
</li>
</ol>
<h4 id="What-will-happen-when-the-datacenter-fails"><a href="#What-will-happen-when-the-datacenter-fails" class="headerlink" title="What will happen when the datacenter fails?"></a>What will happen when the datacenter fails?</h4><ol>
<li>Any put-after operations that originated in the failed datacenter but were not yet copied out will be lost. </li>
<li>The storage required for replication queues in the active datacenters will grow. <ul>
<li>They will be unable to send put-after operations to the failed datacenter, and thus, COPS will be unable to garbage collect those dependencies. </li>
<li>Solutions: Allow the queues to grow if the partition is likely to heal soon, or reconfigure COPS to no longer use the failed datacenter. </li>
</ul>
</li>
</ol>
<h4 id="How-does-COPS-with-conflict-detection-COPS-CD-detect-conflict"><a href="#How-does-COPS-with-conflict-detection-COPS-CD-detect-conflict" class="headerlink" title="How does COPS with conflict detection (COPS-CD) detect conflict?"></a>How does COPS with conflict detection (COPS-CD) detect conflict?</h4><ol>
<li>All put operations carry with them previous version metadata.<ul>
<li>It indicates the most recent previous version of the key that was visible at the local cluster at the time of the write. </li>
</ul>
</li>
<li>All put operations now have an implicit dependency on the previous version.<ul>
<li>This ensures that a new version will only be written after its previous version. </li>
</ul>
</li>
<li>COPS-CD has an applicationspecified convergent conflict handler invoked when a conflict is detected. <ul>
<li>A put operation $new$ to a key (with the previous version $prev$) conflicts with the key’s current visible version $curr$: $prev \neq curr$ if and only if $new$ and $curr$ conflict. </li>
</ul>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Distributed-System/" rel="tag"><i class="fa fa-tag"></i> Distributed System</a>
              <a href="/tags/Consistency-Level/" rel="tag"><i class="fa fa-tag"></i> Consistency Level</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/26/Paper/Distributed/Memcache/" rel="prev" title="Memcache">
                  <i class="fa fa-chevron-left"></i> Memcache
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/27/Paper/Sys4AI/SiloD/" rel="next" title="SiloD">
                  SiloD <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiyunZhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous">



</body>
</html>
