<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liyun-zhang.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="@[toc] Execute queriesHow are queries planned? The operators are arranged in an abstract syntax tree. Data flows from the leaves of the tree up towards the root.  The leaf nodes are access methods, e.">
<meta property="og:type" content="article">
<meta property="og:title" content="06 Operator Algorithms">
<meta property="og:url" content="http://liyun-zhang.github.io/2023/06/28/Courses/15445/06-Operator-Algorithms/index.html">
<meta property="og:site_name" content="LiyunZhang">
<meta property="og:description" content="@[toc] Execute queriesHow are queries planned? The operators are arranged in an abstract syntax tree. Data flows from the leaves of the tree up towards the root.  The leaf nodes are access methods, e.">
<meta property="og:locale">
<meta property="article:published_time" content="2023-06-28T05:16:33.000Z">
<meta property="article:modified_time" content="2024-03-16T06:50:53.270Z">
<meta property="article:author" content="LiyunZhang">
<meta property="article:tag" content="Database System">
<meta property="article:tag" content="External Algorithms">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://liyun-zhang.github.io/2023/06/28/Courses/15445/06-Operator-Algorithms/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://liyun-zhang.github.io/2023/06/28/Courses/15445/06-Operator-Algorithms/","path":"2023/06/28/Courses/15445/06-Operator-Algorithms/","title":"06 Operator Algorithms"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>06 Operator Algorithms | LiyunZhang</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LiyunZhang</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Execute-queries"><span class="nav-number">1.</span> <span class="nav-text">Execute queries</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#How-are-queries-planned"><span class="nav-number">1.1.</span> <span class="nav-text">How are queries planned?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-the-assumption-of-algorithms-in-database-systems"><span class="nav-number">1.2.</span> <span class="nav-text">What is the assumption of algorithms in database systems?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sort"><span class="nav-number">2.</span> <span class="nav-text">Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-implementation-should-we-use-to-execute-a-query-containing-an-ORDER-BY-with-a-LIMIT"><span class="nav-number">2.1.</span> <span class="nav-text">What implementation should we use to execute a query containing an ORDER BY with a LIMIT?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-if-the-data-is-too-large-to-fit-in-memory-for-any-clause-including-ORDER-BY-with-a-LIMIT"><span class="nav-number">2.2.</span> <span class="nav-text">What if the data is too large to fit in memory? (for any clause including ORDER BY with a LIMIT)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-perform-an-external-merge-sort"><span class="nav-number">2.3.</span> <span class="nav-text">How to perform an external merge sort?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-can-we-hide-the-disk-I-O"><span class="nav-number">2.4.</span> <span class="nav-text">How can we hide the disk I&#x2F;O?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-can-we-optimize-comparison"><span class="nav-number">2.5.</span> <span class="nav-text">How can we optimize comparison?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-use-B-Tree-for-sorting-since-it-is-sorted"><span class="nav-number">2.6.</span> <span class="nav-text">How to use B+Tree for sorting since it is sorted?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Aggregations"><span class="nav-number">3.</span> <span class="nav-text">Aggregations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#How-can-we-implement-aggregations"><span class="nav-number">3.1.</span> <span class="nav-text">How can we implement aggregations?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-do-hashing-when-spilling-data-onto-a-disk"><span class="nav-number">3.2.</span> <span class="nav-text">How to do hashing when spilling data onto a disk?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Join"><span class="nav-number">4.</span> <span class="nav-text">Join</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Why-do-we-need-to-join"><span class="nav-number">4.1.</span> <span class="nav-text">Why do we need to join?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-are-join-algorithms-doing"><span class="nav-number">4.2.</span> <span class="nav-text">What are join algorithms doing?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-are-the-outputs-of-join-algorithms"><span class="nav-number">4.3.</span> <span class="nav-text">What are the outputs of join algorithms?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-can-we-measure-the-cost-of-join"><span class="nav-number">4.4.</span> <span class="nav-text">How can we measure the cost of join?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Join-algorithms"><span class="nav-number">4.5.</span> <span class="nav-text">Join algorithms</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nested-loop-join"><span class="nav-number">4.5.1.</span> <span class="nav-text">Nested loop join</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#What-is-the-most-naive-algorithm"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">What is the most naive algorithm?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-can-we-better-use-the-data-already-read-from-disk"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">How can we better use the data already read from disk?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-can-we-take-advantage-of-more-buffer-space"><span class="nav-number">4.5.1.3.</span> <span class="nav-text">How can we take advantage of more buffer space?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Can-we-avoid-sequential-scans-by-using-an-index"><span class="nav-number">4.5.1.4.</span> <span class="nav-text">Can we avoid sequential scans by using an index?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sort-merge-join"><span class="nav-number">4.5.2.</span> <span class="nav-text">Sort-merge join</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#What-is-the-process-of-sort-merge-join"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">What is the process of sort-merge join?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-do-the-two-cursors-move"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">How do the two cursors move?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#When-is-sort-merge-join-useful"><span class="nav-number">4.5.2.3.</span> <span class="nav-text">When is sort-merge join useful?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-join"><span class="nav-number">4.5.3.</span> <span class="nav-text">Hash join</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-hash-join-work"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">How does hash join work?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-big-of-a-table-can-we-hash-using-this-approach"><span class="nav-number">4.5.3.2.</span> <span class="nav-text">How big of a table can we hash using this approach?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Can-we-optimize-the-search-for-tuples-that-do-not-have-any-match"><span class="nav-number">4.5.3.3.</span> <span class="nav-text">Can we optimize the search for tuples that do not have any match?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#What-if-we-lack-the-memory-to-fit-the-entire-hash-table"><span class="nav-number">4.5.3.4.</span> <span class="nav-text">What if we lack the memory to fit the entire hash table?</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LiyunZhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">

  
  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://liyun-zhang.github.io/2023/06/28/Courses/15445/06-Operator-Algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LiyunZhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="06 Operator Algorithms | LiyunZhang">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          06 Operator Algorithms
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-28 13:16:33" itemprop="dateCreated datePublished" datetime="2023-06-28T13:16:33+08:00">2023-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-03-16 14:50:53" itemprop="dateModified" datetime="2024-03-16T14:50:53+08:00">2024-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Open-Courses/" itemprop="url" rel="index"><span itemprop="name">Open Courses</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Open-Courses/CMU-15-445-645-Database-System/" itemprop="url" rel="index"><span itemprop="name">CMU 15-445/645 Database System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>@[toc]</p>
<h1 id="Execute-queries"><a href="#Execute-queries" class="headerlink" title="Execute queries"></a>Execute queries</h1><h2 id="How-are-queries-planned"><a href="#How-are-queries-planned" class="headerlink" title="How are queries planned?"></a>How are queries planned?</h2><ol>
<li>The operators are arranged in an abstract syntax tree. Data flows from the leaves of the tree up towards the root. </li>
<li>The leaf nodes are access methods, e.g., scanning index and scanning table, feeding data up along its path to its parent node to do the processing. </li>
<li>The output of the root node is the result of the query. </li>
<li>This tree only describes a logical plan, i.e., instead of telling what implementation to use, it is just the logical flow we want. SQL only declares a logical plan, while the database system’s job is figuring out the optimal execution. </li>
</ol>
<h2 id="What-is-the-assumption-of-algorithms-in-database-systems"><a href="#What-is-the-assumption-of-algorithms-in-database-systems" class="headerlink" title="What is the assumption of algorithms in database systems?"></a>What is the assumption of algorithms in database systems?</h2><ol>
<li>Just like it cannot assume that a table fits entirely in memory, a disk-oriented DBMS cannot assume that query results fit in memory. </li>
<li>We will use the buffer pool to implement algorithms that need to spill to disk. </li>
<li>We will also prefer algorithms that maximize the amount of sequential I/O.</li>
</ol>
<h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><h2 id="What-implementation-should-we-use-to-execute-a-query-containing-an-ORDER-BY-with-a-LIMIT"><a href="#What-implementation-should-we-use-to-execute-a-query-containing-an-ORDER-BY-with-a-LIMIT" class="headerlink" title="What implementation should we use to execute a query containing an ORDER BY with a LIMIT?"></a>What implementation should we use to execute a query containing an ORDER BY with a LIMIT?</h2><ol>
<li>The DBMS only needs to scan the data once to find the top-N elements. </li>
<li>The ideal scenario for heapsort is when the top-N elements fit in memory so that the DBMS only has to maintain an in-memory sorted priority queue while scanning the data. </li>
</ol>
<h2 id="What-if-the-data-is-too-large-to-fit-in-memory-for-any-clause-including-ORDER-BY-with-a-LIMIT"><a href="#What-if-the-data-is-too-large-to-fit-in-memory-for-any-clause-including-ORDER-BY-with-a-LIMIT" class="headerlink" title="What if the data is too large to fit in memory? (for any clause including ORDER BY with a LIMIT)"></a>What if the data is too large to fit in memory? (for any clause including ORDER BY with a LIMIT)</h2><ol>
<li>We do not want to use quick sort in this scenario since data spilling to disk will cause too many random access. </li>
<li>We can use external merge sort that splits data into separate runs, sorts them individually, and then combines them into longer sorted runs. </li>
<li>A run is a list of key/value pairs. <ul>
<li>Keys are the attribute(s) used to compare and compute the sort order. </li>
<li>Values have two choices: it can either be the actual tuple data (i.e., early materialization) or be the Record IDs (i.e., late materialization)<ul>
<li>The advantage of early materialization is that it can produce results faster, while the disadvantage is that it needs to copy more data during the procedure. </li>
<li>The advantage of late materialization is that it can only fetch wanted data while it needs to find the actual data elsewhere (probably involving another disk I/O). </li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="How-to-perform-an-external-merge-sort"><a href="#How-to-perform-an-external-merge-sort" class="headerlink" title="How to perform an external merge sort?"></a>How to perform an external merge sort?</h2><ol>
<li>Data is broken up into $N$ pages. The DBMS has a finite number of $B$ buffer pool pages to hold input and output data.</li>
<li>In the first phase, sort chunks of data that fit in memory and then write back the sorted chunks to a file on disk. <ul>
<li>In the first pass, we can read all $B$ pages of the table into memory, sort pages into runs, and write them back to disk. </li>
<li>Do not sort in the buffer since we do not wish other threads to see some partially sorted data, which may cause errors. Copy the data to somewhere else and copy it back to the buffer after it is sorted. </li>
</ul>
</li>
<li>In the second phase, combine sorted runs into larger chunks. <ul>
<li>In the following passes, each pass use $B-1$ pages for input and $1$ page for output. </li>
<li>Recursively merge pairs of runs into runs $B-1$-times as long. </li>
</ul>
</li>
<li>In general, the first pass creates $\lceil N/B\rceil$ sorted runs of size $B$ and the following passes are $(B-1)$-way merge. <ul>
<li>The number of passes is $1+\lceil\log_{B-1}\lceil N/B\rceil\rceil$. </li>
<li>The total I/O cost is $2N\cdot (number\ of\ passes)$. </li>
</ul>
</li>
<li>In a 2-way external merge sort, instead of sorting the $B$ pages into a run in the first pass, each page is sorted into a run. <ul>
<li>So, the number of passes is $1+\lceil\log_2N\rceil$. </li>
</ul>
</li>
</ol>
<h2 id="How-can-we-hide-the-disk-I-O"><a href="#How-can-we-hide-the-disk-I-O" class="headerlink" title="How can we hide the disk I/O?"></a>How can we hide the disk I/O?</h2><ol>
<li>A typical setup is using $3$ pages ($2$ for input pages and $1$ for output page). Even if we have more buffer space available ($B&gt;3$), it does not effectively utilize them if the worker must block disk I/O. </li>
<li>We can prefetch the next run in the background and store it in a second buffer while the system processes the current run. </li>
<li>This method continuously utilizes the disk to reduce the wait time for I/O requests at each step. </li>
</ol>
<h2 id="How-can-we-optimize-comparison"><a href="#How-can-we-optimize-comparison" class="headerlink" title="How can we optimize comparison?"></a>How can we optimize comparison?</h2><ol>
<li>The first approach is code specialization. <ul>
<li>Instead of providing a comparison function as a pointer to the sorting algorithm, create a hardcoded version of the sort that is specific to a key type. </li>
</ul>
</li>
<li>For string keys, the second approach is suffix truncation. <ul>
<li>First, compare a binary prefix of keys instead of a slower string comparison. </li>
<li>Fallback to a slower version if prefixes are equal. </li>
</ul>
</li>
</ol>
<h2 id="How-to-use-B-Tree-for-sorting-since-it-is-sorted"><a href="#How-to-use-B-Tree-for-sorting-since-it-is-sorted" class="headerlink" title="How to use B+Tree for sorting since it is sorted?"></a>How to use B+Tree for sorting since it is sorted?</h2><ol>
<li>If the table that must be sorted already has a B+Tree index on the sort attribute(s), then we can use that to accelerate sorting. </li>
<li>Retrieve tuples in desired order by traversing the tree’s leaf pages. <ul>
<li>For clustered B+Tree, this is always better than external sorting because there is no computational cost, and all disk access is sequential. </li>
<li>For non-clustered B+Tree, this is almost always a bad idea. In general, one I/O per data record. </li>
</ul>
</li>
</ol>
<h1 id="Aggregations"><a href="#Aggregations" class="headerlink" title="Aggregations"></a>Aggregations</h1><h2 id="How-can-we-implement-aggregations"><a href="#How-can-we-implement-aggregations" class="headerlink" title="How can we implement aggregations?"></a>How can we implement aggregations?</h2><ol>
<li>The DBMS needs a way to find tuples with the same distinguishing attributes for grouping quickly. </li>
<li>We can use the aforementioned sorting algorithms for aggregations specified with an <code>ORDER BY</code> clause. </li>
<li>Hashing is a better alternative for queries that do not need the data to be ordered, e.g., forming groups in <code>GROUP BY</code> or removing duplicates in <code>DISTINCT</code>. Hashing can be computationally cheaper than sorting. <ul>
<li>For each record, check whether there is an entry in the hash table. For <code>DISTINCT</code>, discard the duplicate. For <code>GROUP BY</code>, perform aggregate computation. </li>
</ul>
</li>
</ol>
<h2 id="How-to-do-hashing-when-spilling-data-onto-a-disk"><a href="#How-to-do-hashing-when-spilling-data-onto-a-disk" class="headerlink" title="How to do hashing when spilling data onto a disk?"></a>How to do hashing when spilling data onto a disk?</h2><ol>
<li>The first phase is partition. Divide tuples into buckets based on the hash key. Write them out to disk when they get full. <ul>
<li>Use a hash function $h_1$ to split tuples into partitions on the disk. </li>
<li>A partition is one or more pages that contain a set of keys with the same hash value. </li>
<li>Assume that we have $B$ buffers. We will use $B-1$ buffers for the partitions and $1$ buffer for the input data. </li>
</ul>
</li>
<li>The second phase is ReHash. Build an in-memory hash table for each partition and compute the aggregation. <ul>
<li>For each partition on the disk, read it into memory and build an in-memory hash table based on a second hash function $h_2$. </li>
<li>Then, go through each bucket of this hash table to bring together matching tuples. </li>
<li>Each time, we can use $B-1$ pages as input pages and $1$ page as output page. <ul>
<li>In each round, we can read in $B-1$ partitions. </li>
<li>After each round is finished, we can clear the hash table since the next $B-1$ partitions definitely won’t have the same keys as in the last round. </li>
</ul>
</li>
</ul>
</li>
<li>During the ReHash phase, store pairs of the form $(GroupKey→RunningVal)$. <ul>
<li>When we want to insert a new tuple into the hash table if we find a matching $GroupKey$, update the $RunningVal$ appropriately. Else, insert a new $(GroupKey→RunningVal)$. </li>
<li>The running totals of different aggregation functions are as follows:<ul>
<li>$AVG(col)\rightarrow (COUNT,SUM)$</li>
<li>$SUM(col)\rightarrow(SUM)$</li>
<li>$COUNT(col)\rightarrow(COUNT)$</li>
<li>$MIN(col)\rightarrow(MIN)$</li>
<li>$MAX(col)\rightarrow(MAX)$</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h1><h2 id="Why-do-we-need-to-join"><a href="#Why-do-we-need-to-join" class="headerlink" title="Why do we need to join?"></a>Why do we need to join?</h2><ol>
<li>Tables are normalized in a relational database to avoid unnecessary repetition of information. </li>
<li>The join operator reconstructs the original tuples without any information loss. </li>
<li>Join is an important operator in both OLAP and OLTP systems. Especially for the OLAP system, joining could take up to $15\sim 50\%$ of time. </li>
</ol>
<h2 id="What-are-join-algorithms-doing"><a href="#What-are-join-algorithms-doing" class="headerlink" title="What are join algorithms doing?"></a>What are join algorithms doing?</h2><ol>
<li>The most important kind is binary joins using inner equijoin algorithms. <ul>
<li>Binary means that the operator takes two tables as input. </li>
<li>Inner means it matches a certain tuple in the left table with another in the right. </li>
<li>Equijoin means that the condition of matching two tuples is the equivalence of some attributes. </li>
</ul>
</li>
<li>There are also other joins. <ul>
<li>Multi-way joins take more than two tables as input, primarily in the research literature. </li>
<li>Besides equijoin, there could also be anti-join, non-equijoin, etc. </li>
</ul>
</li>
<li>Compared with cross-product, join is more efficient and can be carefully optimized. </li>
</ol>
<h2 id="What-are-the-outputs-of-join-algorithms"><a href="#What-are-the-outputs-of-join-algorithms" class="headerlink" title="What are the outputs of join algorithms?"></a>What are the outputs of join algorithms?</h2><ol>
<li>In <code>R JOIN S</code>, for tuple $r \in R$ and tuple $s \in S$ that match on join attributes, concatenate $r$ and $s$ together into a new tuple. </li>
<li>The output contents can vary depending on the query’s processing model, storage model, or data requirements. </li>
<li>Basically, there are two choices that are similar in terms of sort. <ul>
<li>Early materialization<ul>
<li>Copy the values for the attributes in outer and inner tuples into a new output tuple. </li>
<li>Subsequent query plan operators never need to return to the base tables to get more data.</li>
</ul>
</li>
<li>Late materialization<ul>
<li>Only copy the join keys and the matching tuples’ Record IDs. </li>
<li>This is ideal for column stores because the DBMS does not copy data not needed for the query. </li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="How-can-we-measure-the-cost-of-join"><a href="#How-can-we-measure-the-cost-of-join" class="headerlink" title="How can we measure the cost of join?"></a>How can we measure the cost of join?</h2><ol>
<li>We can measure the join cost by the number of I/Os to compute the join. </li>
<li>Output costs are ignored since they depend on the data. </li>
<li>In the following analysis, we assume there are $m$ tuples stored in $M$ pages in table $R$, $n$ tuples stored in $N$ pages in table $S$. </li>
</ol>
<h2 id="Join-algorithms"><a href="#Join-algorithms" class="headerlink" title="Join algorithms"></a>Join algorithms</h2><h3 id="Nested-loop-join"><a href="#Nested-loop-join" class="headerlink" title="Nested loop join"></a>Nested loop join</h3><h4 id="What-is-the-most-naive-algorithm"><a href="#What-is-the-most-naive-algorithm" class="headerlink" title="What is the most naive algorithm?"></a>What is the most naive algorithm?</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">tuple</span> r <span class="keyword">in</span> R:</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">tuple</span> s <span class="keyword">in</span> S:</span><br><span class="line">    emit, <span class="keyword">if</span> r <span class="keyword">and</span> s <span class="keyword">match</span></span><br></pre></td></tr></table></figure>
<ol>
<li>For $R\bowtie S$, he left the table $R$ in the outer loop is called the outer table, and $S$ is called the inner table. </li>
<li>For every tuple in $R$, it scans $S$ once. The cost is $M+(m\cdot N)$. </li>
<li>If we use the smaller table with fewer tuples as the outer table, we can perform better since the number of pages is significantly smaller than the number of tuples. </li>
</ol>
<h4 id="How-can-we-better-use-the-data-already-read-from-disk"><a href="#How-can-we-better-use-the-data-already-read-from-disk" class="headerlink" title="How can we better use the data already read from disk?"></a>How can we better use the data already read from disk?</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> block B_R <span class="keyword">in</span> R:</span><br><span class="line">  <span class="keyword">for</span> block B_S <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">tuple</span> r <span class="keyword">in</span> B_R:</span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">tuple</span> s <span class="keyword">in</span> B_S:</span><br><span class="line">        emit, <span class="keyword">if</span> r <span class="keyword">and</span> s <span class="keyword">match</span></span><br></pre></td></tr></table></figure>
<ol>
<li>For every read block $B_R$ and $B_S$, we try to compute as much as possible, i.e., pair all tuples in $B_R$ with all tuples in $B_S$. </li>
<li>Every block in R scans S once. The cost is $M+(M\cdot N)$. </li>
<li>$M\cdot N$ won’t be affected by the order of tables. However, the first term can be smaller if we let the smaller table with fewer pages be the outer table. </li>
</ol>
<h4 id="How-can-we-take-advantage-of-more-buffer-space"><a href="#How-can-we-take-advantage-of-more-buffer-space" class="headerlink" title="How can we take advantage of more buffer space?"></a>How can we take advantage of more buffer space?</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> B-<span class="number">2</span> pages p_R <span class="keyword">in</span> R:</span><br><span class="line">  <span class="keyword">for</span> page p_S <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">tuple</span> r <span class="keyword">in</span> B_2 pages:</span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">tuple</span> s <span class="keyword">in</span> p_S:</span><br><span class="line">        emit, <span class="keyword">if</span> r <span class="keyword">and</span> s <span class="keyword">match</span></span><br></pre></td></tr></table></figure>
<ol>
<li>Use $B-2$ buffers for scanning the outer table. Use one buffer for the inner table and one buffer for storing<br>output. </li>
<li>The cost is $M+(\lceil M/(B-2)\rceil\cdot N)$. </li>
<li>If the outer relation completely fits in memory, the cost is $M+N$. </li>
</ol>
<h4 id="Can-we-avoid-sequential-scans-by-using-an-index"><a href="#Can-we-avoid-sequential-scans-by-using-an-index" class="headerlink" title="Can we avoid sequential scans by using an index?"></a>Can we avoid sequential scans by using an index?</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">tuple</span> r <span class="keyword">in</span> R:</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">tuple</span> s <span class="keyword">in</span> Index(r_i = s_j):</span><br><span class="line">    emit, <span class="keyword">if</span> r <span class="keyword">and</span> s <span class="keyword">match</span></span><br></pre></td></tr></table></figure>
<p>Assume the cost of each index probe is some constant $C$ per tuple. The cost is $M+(m\cdot C)$</p>
<h3 id="Sort-merge-join"><a href="#Sort-merge-join" class="headerlink" title="Sort-merge join"></a>Sort-merge join</h3><h4 id="What-is-the-process-of-sort-merge-join"><a href="#What-is-the-process-of-sort-merge-join" class="headerlink" title="What is the process of sort-merge join?"></a>What is the process of sort-merge join?</h4><ol>
<li>The first phase is to sort both tables using the join key(s). </li>
<li>In the second phase, we step through the two sorted tables with cursors and emit matching tuples. </li>
<li>The sort cost of the outer table is $2M\cdot(1+\lceil \log_{B-1}\lceil M/B\rceil\rceil)$ and the sort cost of the inner table is $2N\cdot (1+\lceil\log_{B-1}\lceil N/B \rceil \rceil)$. </li>
<li>The merge cost is $M+N$. <ul>
<li>The worst case for the merging phase is when the join attribute of all the tuples in both relations contains the same value.</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort R,S on join keys</span><br><span class="line">cursor_R points to R_sorted, cursor_S points to S_sorted</span><br><span class="line"><span class="keyword">while</span> cursor_R <span class="keyword">and</span> cursor_S:</span><br><span class="line">  <span class="keyword">if</span> cursor_R &gt; cursor_S:</span><br><span class="line">    increment cursor_S</span><br><span class="line">  <span class="keyword">if</span> cursor_R &lt; cursor_S:</span><br><span class="line">    increment cursor_R</span><br><span class="line">    possible backtrack cursor_S</span><br><span class="line">  <span class="keyword">elif</span> cursor_R <span class="keyword">and</span> surcor_s <span class="keyword">match</span>:</span><br><span class="line">    emit</span><br><span class="line">    increment cursor_s</span><br></pre></td></tr></table></figure>
<h4 id="How-do-the-two-cursors-move"><a href="#How-do-the-two-cursors-move" class="headerlink" title="How do the two cursors move?"></a>How do the two cursors move?</h4><ol>
<li>The cursor of the outer table will only move forward. Specifically, it will only move forward when we can ensure that we have matched the current tuple with all possible tuples, i.e., when we have a larger inner tuple. </li>
<li>The cursor of the inner table may move both forward and backward. <ul>
<li>It moves forward when some later tuple in the inner table may match with the current tuple in an outer tuple, i.e., when an inner tuple is smaller than the outer tuple or when they match (there are possibly more matches in the following). </li>
<li>It moves backward when there might have been some missing matches in the past, i.e., when the outer cursor moves forward, the key is the same as the last one; we need to backtrack to the earliest tuple that matches the previous outer tuple. </li>
</ul>
</li>
</ol>
<h4 id="When-is-sort-merge-join-useful"><a href="#When-is-sort-merge-join-useful" class="headerlink" title="When is sort-merge join useful?"></a>When is sort-merge join useful?</h4><ol>
<li>We can save some cost when one or both tables are sorted using the join key. </li>
<li>When output must be sorted on the join key, if the join output is larger, we might use sort-merge join to produce sorted output directly. <ul>
<li>If the output has a small amount, hash join might still be the better way. </li>
</ul>
</li>
</ol>
<h3 id="Hash-join"><a href="#Hash-join" class="headerlink" title="Hash join"></a>Hash join</h3><h4 id="How-does-hash-join-work"><a href="#How-does-hash-join-work" class="headerlink" title="How does hash join work?"></a>How does hash join work?</h4><ol>
<li><p>The thought behind hash join is that: </p>
<ul>
<li>If tuple $r \in R$ and a tuple$s \in S$ satisfy the join condition; they have the same value for the join attributes. </li>
<li>If that value is hashed to some partition $i$, the $R$ tuple must be in $r_i$ and the $S$ tuple in $s_i$. </li>
<li>Therefore, $R$ tuples in $r_i$ need only to be compared with $S$ tuples in $s_i$. </li>
</ul>
</li>
<li><p>In the first phase (build), we scan the outer relation and populate a hash table using the hash function $h_1$ on the join attributes. </p>
<p>In the second phase (probe), scan the inner relation and use $h_1$ on each tuple, jump to a location in the hash table, and find a matching tuple. </p>
</li>
<li><p>The keys stored in the hash table are the attribute(s) on which the query is joining the tables. We always need the original key to verify that we have a correct match in case of hash collisions. </p>
<p>The values stored vary per implementation, which depends on what the operators above the join in the query plan expect as its input. </p>
</li>
<li><p>Assume that we have enough buffers, we need to read and write both tables with the cost of $2(M+N)$ in the partitioning phase, and read both tables with the cost of $M+N$ in the probing phase. </p>
<ul>
<li>We can see that there is no constraint on the size of the inner table. </li>
</ul>
</li>
</ol>
<h4 id="How-big-of-a-table-can-we-hash-using-this-approach"><a href="#How-big-of-a-table-can-we-hash-using-this-approach" class="headerlink" title="How big of a table can we hash using this approach?"></a>How big of a table can we hash using this approach?</h4><ol>
<li>In the first phase of building a hash table, we can use at most $B-1$ spill partitions, leaving one page as an input buffer. When one partition is full, we should write it out on the disk and clear it. </li>
<li>total number of both the outer and inner table of each partition should be no more than $B$ blocks big so that in the second phase, we can store all tuples in the same partition in memory. </li>
<li>The total number of pages used is $B\cdot (B-1)$. A hash table of $N$ pages need about $\sqrt{N}$ buffers if the hash distribution is even. </li>
<li>When including the fudge factor $f&gt;1$ when the hash distribution is skewed, we need $B\cdot\sqrt{f\cdot N}$. </li>
</ol>
<h4 id="Can-we-optimize-the-search-for-tuples-that-do-not-have-any-match"><a href="#Can-we-optimize-the-search-for-tuples-that-do-not-have-any-match" class="headerlink" title="Can we optimize the search for tuples that do not have any match?"></a>Can we optimize the search for tuples that do not have any match?</h4><ol>
<li>We can create a Bloom filter during the build phase when the key will likely not exist in the hash table. This method is called Bloom filter or sideways information passing. </li>
<li>The Bloom filter is a probabilistic data structure (bitmap) that answers set membership queries. <ul>
<li>False negatives will never occur, while false positives can sometimes occur. </li>
<li>To insert a key into the filter, we use $k$ hash functions to set all $k$ bits to $1$. </li>
<li>During the lookup of a key, the key may exist if all $k$ bits hashed by the same $k$ hash function are all $1$. The key definitely does not exist if one of the $k$ bits is $0$. </li>
</ul>
</li>
</ol>
<h4 id="What-if-we-lack-the-memory-to-fit-the-entire-hash-table"><a href="#What-if-we-lack-the-memory-to-fit-the-entire-hash-table" class="headerlink" title="What if we lack the memory to fit the entire hash table?"></a>What if we lack the memory to fit the entire hash table?</h4><ol>
<li>We can use the recursive hash join (GRACE hash join). </li>
<li>Similar to the aforementioned algorithm, both tables should be hashed into the same number of buckets with the same hash function. </li>
<li>Perform regular hash join on each pair of matching buckets at the same level between two tables. </li>
<li>If the buckets do not fit in memory, use recursive partitioning to split the tables into chunks that will fit. <ul>
<li>Build another hash table for $bucket_{R,i}$ using hash function $h_2$ (with $h_2≠h_1$). </li>
<li>Then, probe it for each tuple of the other table’s bucket at that level. </li>
</ul>
</li>
<li><strong>Hybrid hash join</strong>: If the keys are skewed, the DBMS keeps the hot partition in-memory and immediately performs the comparison instead of spilling it to disk. </li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Database-System/" rel="tag"><i class="fa fa-tag"></i> Database System</a>
              <a href="/tags/External-Algorithms/" rel="tag"><i class="fa fa-tag"></i> External Algorithms</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/27/OpenSource/BusTub/Project-1-Buffer-Pool/" rel="prev" title="Project #1: Buffer Pool">
                  <i class="fa fa-chevron-left"></i> Project #1: Buffer Pool
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/07/07/OpenSource/BusTub/Project-2-B-Tree/" rel="next" title="Project #2: B+Tree">
                  Project #2: B+Tree <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiyunZhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous">



</body>
</html>
